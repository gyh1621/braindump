+++
title = "Java Grammar"
author = ["Yuhang Guo"]
draft = false
+++

tags
: [Java]({{< relref "20210106174605-java" >}})

source
: [DT-On Java 8](x-devonthink-item://199347D4-709D-41DF-84EA-B02E4E11ACEE)


## <span class="section-num">1</span> Objects {#objects}


### <span class="section-num">1.1</span> Identifiers in Java are all references {#identifiers-in-java-are-all-references}

object references stored in [stack]({{<relref "20210108151044-where_storage_lives.md" >}}), objects stored in [heap]({{<relref "20210108151044-where_storage_lives.md" >}})


### <span class="section-num">1.2</span> Not all identifiers have objects connected {#not-all-identifiers-have-objects-connected}

```java
String s;  // no objects connected
String s = "asdf";  // an object connected
```


### <span class="section-num">1.3</span> Create objects using `new` {#create-objects-using-new}

`String s = new String("asdf");`


## <span class="section-num">2</span> Primitive Types {#primitive-types}

-   variable holds the value directly, placed on the [stack]({{<relref "20210108151044-where_storage_lives.md" >}})
-   sizes of primitive types don't change on different machine architectures
    -   Java has no `sizeof` function, whose main goal is for portability (C, C++)
-   all numeric types are signed
-   size of boolean is defined to take the literal values true or false
-   **Autoboxing** automatically converts a primitive to a wrapped object and back

{{< figure src="/ox-hugo/2021-01-08_16-14-36_BF2055CE-A7AF-43E6-9402-3A84D963D158.png" >}}


## <span class="section-num">3</span> Scoping of variables {#scoping-of-variables}

\#[Object Creation & Lifetime]({{<relref "20210106165752-oop.md" >}})

-   a variable defined inside a scope is no longer accessiable outside of the scope
-   hide a variable in a larger scope is not allowed in Java

    ```java
      {
          int x = 12;
          {
              int x = 96;  // illegal
          }
      }
    ```
-   primitive types are released outside of the scope beacuse they are stored on the [stack]({{<relref "20210108151044-where_storage_lives.md" >}})
-   objects persist past the end of the scope, references are released


## <span class="section-num">4</span> [Namespaces]({{< relref "20210108165204-namespaces" >}}) {#namespaces--20210108165204-namespaces-dot-md}

Java use reversed URLs.
Every file automatically live in their own namespaces.
Each class within a file has a unique identifier.

Problem: deep directory path, many of them are empty (e.g. com)


## <span class="section-num">5</span> `static` keyword {#static-keyword}

\#[static]({{< relref "20210108200839-static" >}})


### <span class="section-num">5.1</span> Purposes {#purposes}

1.  want a single, shared piece of storage for a particular field
2.  want a method that isn't associated with any paticular object of this class


## <span class="section-num">6</span> Casting {#casting}

-   widening conversion: explicitly or implicitly
    -   wider types truncated into narrower types
-   narrowing conversion: explicitly
-   any primitive type can be casted into any other primitive type
    -   except for `boolean`, which doesn't allow casting at all <a id="org5229300"></a>
-   Class type do not allow casting


### <span class="section-num">6.1</span> Promotion {#promotion}

| position | ease | box | interval | due                  |
|----------|------|-----|----------|----------------------|
| front    | 2.50 | 2   | 1.00     | 2021-01-16T18:57:21Z |

Any mathematical or bitwise operations on primitive data types smaller
than int (char, byte, short), those values are promoted to int before
performing the operations, and the resulting values are int, so when
assigning back, there might be some losing information.

If arithmetic operators not combined with equal operator, the result (right side)
must be explicitly cast back to the original type:

```java
short x = 1, y = 2;
s = (short) x * y;
s = (short) ~y;
```


## <span class="section-num">7</span> Operators {#operators}


### <span class="section-num">7.1</span> Shift Operators {#shift-operators}

-   `<<`, inserting zero at the lower-order bits
-   `>>`, value positive: inserting zero at the higher-order bits, value negative: inserting one
-   `>>>`, unsigned right shift, inserting zeros
-   when shifting a char, byte or short, it is promoted to int before shifting, and result is int


#### maximum effective shifting number {#maximum-effective-shifting-number}

| position | ease | box | interval | due                  |
|----------|------|-----|----------|----------------------|
| front    | 2.50 | 2   | 1.00     | 2021-01-16T18:57:07Z |

-   if left operand is int, only FIVE lower-order bits of the right-hand side are used to
    prevent shifting more than the number of bits in an int

    e.g., `5>>32 -> 0`

-   if left operand is long, only SIX lower-order bits of the right-hand side are used


#### special case when combining shift operators with equal sign {#special-case-when-combining-shift-operators-with-equal-sign}

| position | ease | box | interval | due                  |
|----------|------|-----|----------|----------------------|
| front    | 2.50 | 2   | 1.00     | 2021-01-16T18:57:26Z |

If left operand is byte or short, they promoted to int,
then truncated when assigned back, so sometimes get `-1`.

```java
short s = -1;  // 1111-1111-1111-1111
System.out.println(Integer.toBinaryString(s));
s >>>= 10;
// s >>> 10:
//  promoted to int first: 1111-1111-1111-1111-1111-1111-1111-1111
//  right shift 10: 0000-0000-0011-1111-1111-1111-1111-1111
// assign back, truncated: 1111-1111-1111-1111, s remains same
System.out.println(Integer.toBinaryString(s));
s = -1;
s >>>= 17;
System.out.println(Integer.toBinaryString(s));
/*out
11111111111111111111111111111111
11111111111111111111111111111111
111111111111111
*/
```

```java
byte b = -1;
System.out.println(Integer.toBinaryString(b));
b >>>= 10;
System.out.println(Integer.toBinaryString(b));
System.out.println(Integer.toBinaryString(b>>>10));
/* out
11111111111111111111111111111111
11111111111111111111111111111111
1111111111111111111111
*/
```


## <span class="section-num">8</span> Arrays {#arrays}

-   a Java array is guarenteed to be initialized and cannot be accessed outside of its range
-   when creating an array of objects, an array of references (value is `null`) are actually created


## <span class="section-num">9</span> [Access Control]({{< relref "20210106173814-access_control" >}}) {#access-control--20210106173814-access-control-dot-md}

Determine who can use the definitions that follow.

-   public
    The element is available to everyone

-   private
    No one can access that element except the creator.

    Anyone trying to access this kind of elements illegally gets [compile time error]({{< relref "20210106175817-compile_time_error" >}}).

-   protected
    Like **private**, but inheriting class may access **protected** members.

-   default (class)
    Also called **package access**.

    Classes can access members of other classes in the same package.
    Outside the package, these members remain **private**.


## <span class="section-num">10</span> Variable Argument Lists {#variable-argument-lists}

| position | ease | box | interval | due                  |
|----------|------|-----|----------|----------------------|
| front    | 2.5  | 0   | 0        | 2021-01-16T03:46:25Z |


### <span class="section-num">10.1</span> Array of Objects {#array-of-objects}

```java
public class VarArgs {
    static void printArray(Object[] args) {
        for (Object obj: args)
            System.out.print(obj + " ");
    }
    public static void main(String[] args) {
        printArray(new Object[]{
                47, (float) 3.14, 11.11, "string"});
    }
}
```


### <span class="section-num">10.2</span> Ellipses {#ellipses}

-   convert list of elements to an array
-   can take an array as an argument
-   can take empty arguments -> use as ****optional trailing arguments****

<!--listend-->

```java
void printArray(Object... args) {
    for (Object obj: args)
        System.out.print(obj + " ");
}

void printArrayOptional(String arg1, Object... args) {

}

void main() {
    printArray(47, (float) 3.15, 11.11, "one");
    printArray((Object[])new Integer[]{1, 2, 3, 4});
    printArray();
    printArrayOptional("111", 1, "3", 4.32);
    printArrayOptional("111");
}
```


### <span class="section-num">10.3</span> Variable argument list in overloaded methods may cause more than one match when calling {#variable-argument-list-in-overloaded-methods-may-cause-more-than-one-match-when-calling}

```java
void f(float i, char... args);
void f(char... args);

// call with
f('a', 'b');  // won't compile
```


## <span class="section-num">11</span> Enumerated Types {#enumerated-types}

| position | ease | box | interval | due                  |
|----------|------|-----|----------|----------------------|
| front    | 2.5  | 0   | 0        | 2021-01-16T03:58:37Z |

\#[Java Class]({{< relref "20210114095654-java_class" >}})

-   instances of enumerated types are constants

<!--listend-->

```java
public enum Spiciness {
    NOT, MILE, MEDIUM, HOT, FLAMING
}

public class SimpleEnumUse {
    public static void main(String[] args) {
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
        for(Spiciness s : Spiciness.values())
            System.out.println(
                s + ", ordinal " + s.ordinal());
    }
}
/* output:
MEDIUM
NOT, ordinal 0
MILD, ordinal 1
MEDIUM, ordinal 2
HOT, ordinal 3
FLAMING, ordinal 4
*/
```

-   can be used in `switch`

<!--listend-->

```java
switch (degree) {
    case NOT:
    case MILE:
    default: break
}
```


## <span class="section-num">12</span> Other {#other}

-   `%n` handles different line endings on different platforms when using `System.out.printf` or `System.out.format`
-   `e` or `E` means "ten to the power", e.g., 1.38e-43f means 1.38 \* 10-43
-   `goto` is a reversed word in Java, but it's not used
    -   similar grammars are `break label` and `continue label`
    -   only consider using labels is when you have nested loops and must break or continue more than one nested level
